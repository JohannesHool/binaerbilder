{"version":3,"sources":["index.js"],"names":["options","value","label","MyForm","props","imageChangeHandler","event","state","dimension","bitdepth","setState","imageString","target","warnings","dimensionChange","dim","isNaN","bitdepthChangeHandler","placeholderCol","r","g","b","this","x","key","pixelText","pixelColor","pixelDimension","String","parseInt","fontDim","multiplyr","rgb","className","style","backgroundColor","height","width","fontSize","verticalAlign","arr","pixels","i","length","push","renderBinaryPixel","txt","num","result","substr","pixelIndex","grid","text","replace","split","join","textArr","splitNChars","row","j","NaN","image","renderBinaryRow","numPix","display","type","onChange","fontColor","placeholder","getWarning","minHeight","maxHeight","minWidth","maxWidth","renderBinaryImage","renderErrors","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6c0c9cd2.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Select from 'react-select';\nimport './index.css';\n\nconst options = [\n  { value: 1, label: '1 Bit' },\n  { value: 2, label: '2 Bit' },\n  { value: 8, label: '8 Bit' },\n];\n\n\nclass MyForm extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      imageString: '',\n      dimension: 0,\n      warnings: [],\n      bitdepth: 0,\n      placeholderCol: 'red'\n    };\n  }\n\n  imageChangeHandler = (event) => {\n    if (this.state.dimension > 0 && this.state.bitdepth > 0) {\n      this.setState({ imageString: event.target.value });\n      this.setState({ warnings: [] });\n    }\n\n  }\n\n  dimensionChange = (event) => {\n    let max = 20;\n    let dim = event.target.value\n\n    if (isNaN(dim)) dim = 0;\n    if (dim > max) dim = max;\n\n    this.setState({ dimension: dim });\n\n    this.setState({ warnings: [] });\n  }\n\n  bitdepthChangeHandler = (event) => {\n    this.setState({ bitdepth: event.value });\n  }\n\n\n  rgb(r, g, b) {\n    return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n  }\n\n  renderErrors() {\n    // let text = this.state.imageString.replace(/(\\r\\n|\\n|\\r)/gm,\"\");\n    // if (isNaN(Number(this.state.dimension)) || Number(this.state.dimension) === 0) {\n    //   this.state.warnings.push(\"Dimension des Binärbildes noch nicht festgelegt.\")\n    // }\n    // if (text.length < this.state.dimension ** 2) {\n    //   this.state.warnings.push(\"Bit-Abfolge zu kurz.\")\n    // }\n    // if (text.length > this.state.dimension ** 2) {\n    //   this.state.warnings.push(\"Bit-Abfolge zu lang.\")\n    // }\n    // if (text.length > 0) {\n    //   let warning = \"Ein Teil der Bit-Abfolge entspricht nicht dem verlangten Format.\";\n    //   let testBitString = this.state.imageString.split(\"\");\n    //   for (let i = 0; i < testBitString.length; i++) {\n    //     let testNum = Number(testBitString[i]);\n    //     if ((isNaN(testNum) || testNum < 0 || testNum > 1) && !this.state.warnings.includes(warning)) {\n    //       this.state.warnings.push(warning);\n    //     }\n    //   }\n    // }\n\n    // return (\n    //   <div className=\"error-box\">\n    //     <ul>\n    //       {this.state.warnings.map(function (item) {\n    //         return <li className=\"warning-entry\" key={item}>{item}</li>;\n    //       })}\n    //     </ul>\n    //   </div>\n    // );\n  }\n\n  getWarning() {\n    if (this.state.dimension <= 0) {\n      return \"Lege zuerst die Dimension des Bildes fest\";\n    } else if (this.state.bitdepth <= 0) {\n      return \"Lege zuerst die Bittiefe des Bildes fest\";\n    } else {\n      return \"\";\n    }\n  }\n\n  renderBinaryPixel(x, key) {\n\n    let pixelText;\n    let pixelColor;\n    let pixelDimension = String(parseInt(400 / this.state.dimension)) + \"px\";\n    let fontDim = String(400 / this.state.dimension) * 1 + \"px\";\n\n    let multiplyr = 255 / (2 ** this.state.bitdepth - 1);\n\n    if (!isNaN(x)) {\n      pixelColor = this.rgb(x * multiplyr, x * multiplyr, x * multiplyr);\n    } else {\n      pixelColor = this.rgb(255, 255, 255);\n    }\n\n    if (!isNaN(x)) {\n      pixelText = \"\";\n    } else {\n      pixelText = \"?\";\n    }\n\n    return (\n      <div\n        className=\"pixel\"\n        key={\"pixel_\" + key}\n        style={{\n          backgroundColor: pixelColor,\n          height: pixelDimension,\n          width: pixelDimension,\n          fontSize: fontDim\n        }}\n      >\n        <span style={{ verticalAlign: \"middle\" }}>{pixelText}</span>\n      </div>\n    );\n  }\n\n  renderBinaryRow(arr, key) {\n\n    let pixels = [];\n    for (let i = 0; i < arr.length; i++) {\n      pixels.push(this.renderBinaryPixel(arr[i], i));\n    }\n\n    return (\n      <div className=\"image-row\" key={\"row\" + key}>\n        {pixels}\n      </div>\n    );\n  }\n\n  splitNChars(txt, num) {\n    var result = [];\n    for (var i = 0; i < txt.length; i += num) {\n      result.push(txt.substr(i, num));\n    }\n    return result;\n  }\n\n\n  renderBinaryImage(arr) {\n\n    let pixelIndex = 0;\n    let grid = [];\n\n    let text = this.state.imageString.replace(/(\\r\\n|\\n|\\r)/gm, \"\").split(' ').join('');\n\n    let textArr = this.splitNChars(text, this.state.bitdepth);\n\n    for (let i = 0; i < this.state.dimension; i++) {\n      let row = [];\n      for (let j = 0; j < this.state.dimension; j++) {\n        let value = textArr[pixelIndex];\n\n        if (value && (value.length == this.state.bitdepth)) {\n          row.push(parseInt(value, 2));\n        } else {\n          row.push(NaN);\n        }\n\n        pixelIndex += 1;\n      }\n      grid.push(row);\n    }\n    let image = [];\n\n    for (let i = 0; i < grid.length; i++) {\n      image.push(this.renderBinaryRow(grid[i], i))\n    }\n\n    return (\n      <div>{image}</div>\n    );\n  }\n\n  render() {\n    let numPix = this.state.dimension ** 2;\n\n    return (\n      <div>\n        <div>\n          <div className=\"area\">\n            <div className=\"area\">\n              <h1>Binärbilder</h1>\n              <ul>\n                <li>Diese Anwendung stellt eine <b>Bit-Sequenz als Schwarz/Weiss-, bzw. Graustufenbild</b> dar.</li>\n                <li>Die Bit-Sequenz wird entsprechend der <b>Bittiefe</b> in 1-Bit, 2-Bit oder 8-Bit Binärzahlen unterteilt</li>\n                <li>Der kleinstmögliche Wert entspricht der Farbe <b>Schwarz</b>, der grösstmögliche Wert entspricht der Farbe <b>Weiss</b></li>\n              </ul>\n            </div>\n            <div style={{ display: \"table\" }}>\n              <div className=\"area\">\n                <h2>Dimension des Bildes</h2>\n                <p className=\"input-description\"> Anzahl Pixel pro Zeile/Spalte (max = 20): </p>\n                <input type=\"text\" className=\"small-text-input\" onChange={this.dimensionChange}></input>\n                <p>Total Anzahl Pixel: {numPix}</p>\n                <h2>Bittiefe</h2>\n                <Select onChange={this.bitdepthChangeHandler} options={options}\n                />\n                <h2>Abfolge der Bits:</h2>\n                <textarea type='text' style={{ width: \"300px\", fontColor: \"red\" }} onChange={this.imageChangeHandler} placeholder={this.getWarning()} />\n                <p>Nötige Länge der Bitabfolge: Pixel*Bittiefe = {this.state.dimension ** 2} * {this.state.bitdepth} = {this.state.dimension ** 2 * this.state.bitdepth} Bits</p>\n                <p>Aktuelle Länge der Bitabfolge: {this.state.imageString.replace(/(\\r\\n|\\n|\\r)/gm, \"\").split(' ').join('').length}</p>\n              </div>\n              <div className=\"area\">\n                <h2>Resultierendes Binärbild:</h2>\n                <div style={{ backgroundColor: \"white\", display: \"block\", minHeight: \"400px\", maxHeight: \"400px\", minWidth: \"400px\", maxWidth: \"400px\" }}>\n                  {this.renderBinaryImage(this.state.imageString)}\n                </div>\n                {this.renderErrors()}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\n// ============================================================\n\nReactDOM.render(\n  <MyForm />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}